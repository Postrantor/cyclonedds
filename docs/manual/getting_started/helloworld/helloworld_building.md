# Building HelloWorld with CMake

In the Installation `test__install`{.interpreted-text role="ref"} section, the `helloworld_test`{.interpreted-text role="ref"} test used the files in the default installation. Another way is to use the build tool.

> 在安装`test__install`｛.depreted text role=“ref”｝部分，`helloworld_test`｛.epreted text role=“ref”}测试使用默认安装中的文件。另一种方法是使用构建工具。

CMake is an open-source, cross-platform family of tools to build, test, and package software. It controls the software compilation process using simple platform and compiler-independent configuration files. It also generates the native makefiles, projects, and workspaces of your development environment. CMake's main strength is built portability. The same CMake input files can be built with GNU make, Visual Studio (6,7,8) IDEs, Borland make, nmake, and XCode, and so on.

> CMake 是一个开源、跨平台的工具系列，用于构建、测试和打包软件。它使用简单的平台和与编译器无关的配置文件来控制软件编译过程。它还生成开发环境的本地 makefile、项目和工作区。CMake 的主要优势在于内置的便携性。相同的 CMake 输入文件可以使用 GNU make、Visual Studio（6,7,8）IDE、Borland make、nmake 和 XCode 等构建。

Another advantage of CMake is building out-of-source. It simply works out of the box. This facilitates:

> CMake 的另一个优势是源代码构建。它只是开箱即用。这有助于：

- Easy cleanup (no cluttering the source tree). Remove the build directory to start from scratch.
- Multiple build targets. It is possible to have up-to-date debug and release targets without having to recompile the entire tree. It is easy for systems that do the cross-platform compilation to have up-to-date builds for the host and target platform.

> - 易于清理（不会弄乱源代码树）。删除生成目录以从头开始。
> - 多个生成目标。可以拥有最新的调试和发布目标，而无需重新编译整个树。进行跨平台编译的系统很容易获得主机和目标平台的最新版本。

To use CMake, you must provide a `CMakeLists.txt`, a copy of which, can be found in the `<cyclonedds-directory>examples/helloworld` directory that comes with the **Hello World!** example. The content is shown below:

> 要使用 CMake，您必须提供`CMakeLists.txt`，其副本可以在**Hello World！**附带的`<cyclonedsdirectory>examples/helloworld`目录中找到实例内容如下所示：

The content of the `CMakeLists.txt` is:

```cmake
project(helloworld LANGUAGES C CXX)
cmake_minimum_required(VERSION 3.5)

if (NOT TARGET CycloneDDS CXX::ddscxx)
find_package(CycloneDDS CXX REQUIRED)
endif()

# Convenience function, provided by the idlc backend for CXX that generates a CMake
# target for the given IDL file. The function calls idlc to generate
# source files and compiles them into a library.
idlcxx_generate(TARGET ddscxxHelloWorldData_lib FILES HelloWorldData.idl WARNINGS no-implicit-extensibility)

add_executable(ddscxxHelloworldPublisher publisher.cpp)
add_executable(ddscxxHelloworldSubscriber subscriber.cpp)

# Link both executables to IDL data type library and ddscxx.
target_link_libraries(ddscxxHelloworldPublisher ddscxxHelloWorldData_lib CycloneDDS CXX::ddscxx)
target_link_libraries(ddscxxHelloworldSubscriber ddscxxHelloWorldData_lib CycloneDDS CXX::ddscxx)

set_property(TARGET ddscxxHelloworldPublisher PROPERTY CXX_STANDARD 11)
set_property(TARGET ddscxxHelloworldSubscriber PROPERTY CXX_STANDARD 11)
```

To build a based application, you must link your business code to the following:

> 要构建基于应用程序，您必须将业务代码链接到以下内容：

- The `ddsc` library that contains the DDS API for the application.
- The helper functions and structures that represent your datatypes. These helpers are generated by the IDL compiler and can be accessed through the CMake (`idlc_generate`) call that takes the idl file (for example, `HelloWorld.idl`) as input, then packages the datatyped helpers in a library (for example, `HelloWorldData_lib`).

> - “ddsc”库，该库包含应用程序的 DDS API。
> - 表示数据类型的辅助函数和结构。这些帮助程序由 IDL 编译器生成，可以通过 CMake（`idlc_generate`）调用访问，该调用将 IDL 文件（例如`HelloWorld.IDL`）作为输入，然后将数据类型的帮助程序打包到库中（例如`HelloWorldData_lib`）。

The `idlc_generate` call makes use of how the IDL compiler generates the helpers' functions and structures. The following diagram shows the process:

> “idlc_generate”调用利用 IDL 编译器如何生成 helpers 的函数和结构。下图显示了该过程：

![image](/_static/gettingstarted-figures/dds-application-design.png)

The executables of the -based application (`HelloworldPublisher` and `HelloworldSubscriber`) are linked to with the CMake `target_link_libraries()` call. This call combines the `ddsc` lib, the datatype helper lib and the application code.

> 基于的应用程序的可执行文件（`HelloorldPublisher`和`HelloorldSubscriber`）通过 CMake`target_link_libraries（）`调用链接到。此调用组合了“ddsc”库、数据类型帮助器库和应用程序代码。

CMake attempts to find the `CycloneDDS` CMake package in the default system locations. If you experience problems with not being able to locate `CycloneDDS` it is often enough to include the \<install-location\> as CMake Prefix Path. For example: `cmake -DCMAKE_PREFIX_PATH=<install-location>`. If you have further issues, please refer to CMake's .

> CMake 尝试在默认系统位置中查找“CycloneDDS”CMake 包。如果您遇到无法定位“CycloneDDS”的问题，通常只需将“安装位置”作为 CMake 前缀路径。例如：`cmake-DCMAKE_PREFIX_PATH=<安装位置>`。如果您还有其他问题，请参阅 CMake's。

- `|var-project-short| C++` libraries that contain the DDS CXX API your application needs.
- The wrapper classes and structures that represent your datatypes and the customized-DataWriter's and readers that can handle these data types. The CMake statement generates these classes `idlcxx_generate()` that incepts the IDL file invokes the IDL compiler and packages the datatype wrapper classes in a library (e.g. `ddscxxHelloWorldData_lib`).

> - 表示数据类型的包装类和结构，以及可以处理这些数据类型的自定义 DataWriter 和读取器。CMake 语句生成这些类“idlcxx_generate（）”，该类启动 IDL 文件调用 IDL 编译器并将数据类型包装类打包到库中（例如“ddscxxHelloWorldData_lib”）。

This process is outlined as follows:

![image](/_static/gettingstarted-figures/6.1.1-1.png)

Setting the property for the applications in the CMake `set_property()` statement compiles the application against the `C++ 11` standard.

> 在 CMake“set_property（）”语句中设置应用程序的属性将根据“C++11”标准编译应用程序。

The application executable (`ddscxxHellowordPublisher`) is built with the CMake `target_link_libraries()` statement which links the ddscxx lib, the datatype wrapper classes lib (e.g `ddscxxHelloWorldData_lib`) and the application code lib.

> 应用程序可执行文件（`ddscxxHelloordPublisher`）是用 CMake`target_link_libraries（）`语句构建的，该语句链接 ddscxx-lib、数据类型包装类 lib（例如`ddscxxHelloWorldData_lib`）和应用程序代码 lib。

CMake tries to find the `CycloneDDS` and `CycloneDDSCXX` CMake packages, the details regarding how to locate those packages are described in the next section. When the packages are found, every path and dependencies are automatically set.

> CMake 试图找到“CycloneDDS”和“CycloneDDSCXX”CMake 包，有关如何定位这些包的详细信息将在下一节中描述。当找到包时，每个路径和依赖项都会自动设置。

## Building the HelloWorld Example

We recommend that to build examples or applications out-of-source, create a `build` directory inside the copy of the HelloWorld example directory.

> 我们建议，要从源代码外构建示例或应用程序，请在 HelloWorld 示例目录的副本中创建一个“构建”目录。

1.  Open a terminal inside the directory with the HelloWorld files.

2.  Run:

    ```bash
    mkdir build
    cd build
    ```

3.  Configure the build environment:

    ```bash
    cmake -DCMAKE_PREFIX_PATH=<install-location> ..
    ```

    On Windows you can build with one of several generators. Usually if you omit the `-G <generator-name>` it will pick a sensible default, but if it doesn't work or picks something unexpected you can go to the [CMake generators documentation](https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html). For example, "Visual Studio 15 2017 Win64" targets a 64-bit build using Visual Studio 2017.

    > 在 Windows 上，您可以使用多个生成器之一进行构建。 通常，如果您省略 `-G <generator-name>`，它会选择一个合理的默认值，但如果它不起作用或选择了意想不到的东西，您可以转到 [CMake 生成器文档](https://cmake.org /cmake/help/latest/manual/cmake-generators.7.html）。 例如，“Visual Studio 15 2017 Win64”针对使用 Visual Studio 2017 的 64 位构建。

    > [!Warning]
    > If manually specifying generators be careful about mixing and matching! If you compiled with 32-bit libraries and you try to compile **Hello World!** as 64-bit or vice-versa it will not work.
    > Weird things can happen if you mix `-DCMAKE_BUILD_TYPE=Release`, `-DCMAKE_BUILD_TYPE=RelWithDebInfo` and `-DCMAKE_BUILD_TYPE=Debug`, try to match what you picked for in downstream projects.

    > 如果手动指定生成器，请注意混合和匹配！ 如果您使用 32 位库进行编译并尝试将 **Hello World!** 编译为 64 位库，反之亦然，它将无法正常工作。
    > 如果混合使用“-DCMAKE_BUILD_TYPE=Release”、“-DCMAKE_BUILD_TYPE=RelWithDebInfo”和“-DCMAKE_BUILD_TYPE=Debug”，可能会发生奇怪的事情，尝试匹配您在下游项目中选择的内容。

4.  CMake uses the `CMakeLists.txt` in the HelloWorld directory to create "makefiles" that target the native platform. The build directory is now ready to build the `HelloworldPublisher` and `HelloworldSubscriber` executables. Run:

> 4.CMake 使用 HelloWorld 目录中的“CMakeLists.txt”创建针对本机平台的“makefiles”。生成目录现在已准备好生成“HelloorldPublisher”和“HelloorldSubscriber”可执行文件。运行时间：

    ```bash
    cmake --build .
    ```

    Your build directory now contains your executables (on Windows they may be in a `Release` or `Debug` subdirectory).

## Test the build

1.  Open two terminals inside the directory with the HelloWorld files.
2.  In the first terminal, start the subscriber by running `HelloWorldSubscriber`.

    ```bash
    ./HelloworldSubscriber
    ```

3.  In the second terminal, start the publisher by running `HelloWorldPublisher`.

    ```bash
    ./HelloworldPublisher
    ```

`HelloworldPublisher` appears as follows:
![image](/_static/gettingstarted-figures/helloworld_publisher.png)

`HelloworldSubscriber` appears as follows:
![image](/_static/gettingstarted-figures/helloworld_subscriber.png)
