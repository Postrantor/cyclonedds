# Generating C99 source file: ops structure

As part of the C99 source file, there is an array of uint32_t specifying the operation codes for (de)marshalling the data from and to the data structures defined in the generated header file.

> 作为 C99 源文件的一部分，有一个 uint32_t 数组，用于指定操作代码，用于将数据从生成的头文件中定义的数据结构编组(去编组)到数据结构。

This sequence is generated by starting with the struct and output some operation codes for each of the members of the struct, followed by a return operation code.

> 这个序列是从结构开始生成的，并为结构的每个成员输出一些操作代码，然后是返回操作代码。

## Basic types

For members with a basic type, at least two uint32_t values are used. The first specifies the operation and the second and following the operands. The operation is specified by combining (with bit-or) flags. The flags specify:

> 对于具有基本类型的成员，至少使用两个 uint32_t 值。第一个指定运算，第二个指定后面的操作数。该操作是通过组合(与位或)标志来指定的。标志指定：

- The type of the member. For the basic type this specifies the size of the type. For string and bounded string, separate flags are used.
- Whether the field is a key field
- Whether it is an array. If it is an extra operand will speficify the total size of the array (by multiplying the sizes of the various dimensions).
- Whether the type is a sequence. (In case the elment type is a struct, additional information will follow the operation and its operands, as described below.) In case of a bounded string, an extra operand will follow, to specify the size (including its terminating null-character) of the bounded string.

> - 成员的类型。对于基本类型，这指定了类型的大小。对于字符串和有界字符串，使用单独的标志。
> - 字段是否为关键字段
> - 是否为数组。如果是，则额外的操作数将指定数组的总大小(通过乘以不同维度的大小)。
> - 类型是否为序列。(如果 elment 类型是一个结构，则操作及其操作数后面会有额外的信息，如下所述。)如果是有界字符串，则后面会有一个额外的操作数，用于指定有界字符串的大小(包括其终止的 null 字符)。

The operand for a simple type makes such of 'offsetof', which returns the offset of a field in a struct.

> 简单类型的操作数产生了“offsetof”，它返回结构中字段的偏移量。

### Examples of nummeric fields

Given the IDL struct definition:

```C
struct M {
    char ch;
    short i;
    unsigned long ul;
    long long ll;
    float f;
    double d;
};
```

will need the following operation codes (using the predefinted macros):

> 将需要以下操作代码(使用预先定义的宏)：

```C
DDS_OP_ADR | DDS_OP_TYPE_1BY, offsetof (M, chr),
DDS_OP_ADR | DDS_OP_TYPE_2BY, offsetof (M, i),
DDS_OP_ADR | DDS_OP_TYPE_4BY, offsetof (M, ul),
DDS_OP_ADR | DDS_OP_TYPE_8BY, offsetof (M, ll),
DDS_OP_ADR | DDS_OP_TYPE_4BY, offsetof (M, f),
DDS_OP_ADR | DDS_OP_TYPE_8BY, offsetof (M, d),
DDS_OP_RTS,
```

The [DDS_OP_ADR]{.title-ref} macro indicates that the operand will be an address. The [DDS_OP_TYPE_1BY]{.title-ref} to [DDS_OP_TYPE_8BY]{.title-ref} specify the size of the data type. Note that there is no difference between signed and unsigned integer values. In case one of the fields is a key the [ | DDS_OP_FLAG_KEY]{.title-ref} will be added to the operator.

> [DDS_OP_ADR]｛.title-ref｝宏指示操作数将是一个地址。[DDS_OP_TYPE_1BY]｛.title ref｝到[DDS_OP_TYPE_8BY]｛.title ref}指定数据类型的大小。请注意，有符号整数值和无符号整数值之间没有区别。如果其中一个字段是键，则[|DDS_OP_FLAG_key]｛.title-ref｝将添加到运算符中。

The [DDS_OP_RTS]{.title-ref} is to indicate the end of the operation codes for the structure.

### Examples of strings

Given the IDL struct definition:

```C
struct M {
    string str;
    string<4> str4;
};
```

will need the following operation codes:

```C
DDS_OP_ADR | DDS_OP_TYPE_STR, offsetof (M, str),
DDS_OP_ADR | DDS_OP_TYPE_BST, offsetof (M, str4), 5,
DDS_OP_RTS,
```

### Example of a sequence of a basic type

Given the IDL struct definition:

> 给定 IDL 结构定义：

```C
struct M {
    sequence<long> longs;
    sequence<string> strings;
};
```

will need the following operation codes:

```C
DDS_OP_ADR | DDS_OP_TYPE_SEQ | DDS_OP_SUBTYPE_4BY, offsetof (M, longs),
DDS_OP_ADR | DDS_OP_TYPE_SEQ | DDS_OP_SUBTYPE_STR, offsetof (M, strings),
DDS_OP_RTS,
```

In this the [DDS_OP_SUBTYPE_<x>]{.title-ref} define that the element type of the sequence as being [DDS_OP_TYPE_<x>]{.title-ref}.

> 在本文中，[DDS_OP_SUBTYPE_<x>]{.title-ref}将序列的元素类型定义为[DDS_OP_type_<x>]{.title-ref}。

### Example of an array of a basic type

Given the IDL struct definition:

```C
struct M {
    long arr[4][5];
};
```

wil need the following operation codes:

```C
DDS_OP_ADR | DDS_OP_TYPE_ARR | DDS_OP_SUBTYPE_4BY, offsetof (M, arr), 20,
DDS_OP_RTS,
```

Note that 20 is the product of 4 and 5.

## Member that is a struct itself

When a member is a struct (both embedded and refered), the members of that struct are also included, where in [offsetof]{.title-ref} the selection of the nested field is used. For example, [coord.x]{.title-ref} when the member has the name [coord]{.title-ref} and uses a struct that has a member with name [x]{.title-ref}.

> 当一个成员是一个结构(包括嵌入的和引用的)时，该结构的成员也包括在内，其中在[offsetof]{.title-ref}中使用嵌套字段的选择。例如，当成员的名称为[cord]｛.title-ref｝并使用具有名称为[x]｛.title-ref}的成员的结构时，为[cord.x]｛\title-rev｝。

## Sequence of struct or sequence

In case of a member that is a sequence of struct, the definition of the struct also needs to be included. The operation codes need to include the size of the struct and two addresses that specify where the operation codes of for the structure start and where they end. The, so called, jsr address specifies the offset from the start of the current operand to the start of the operation codes for the structure. The, so called, jmp address specifies the offset from the start of the current operand to the operation codes for the following element. Both addresses are 16 bits and stored together in one 32 unsigned long, such that the lower order 16 bits contain the jsr address and the higher order the jmp address. The operation codes describing the struct are terminated with a return operation ([DDS_OP_RTS]{.title-ref}).

> 如果成员是结构的序列，则还需要包括结构的定义。操作代码需要包括结构的大小和两个地址，这两个地址指定结构的操作代码的起始位置和结束位置。所谓的 jsr 地址指定从当前操作数开始到结构的操作码开始的偏移量。所谓的 jmp 地址指定从当前操作数的开始到以下元素的操作码的偏移量。这两个地址都是 16 位，并且一起存储在一个 32 无符号长的地址中，因此低阶的 16 位包含 jsr 地址，高阶的包含 jmp 地址。描述结构的操作代码以返回操作([DDS_OP_RTS]｛.title-ref｝)终止。

The case of a member is a sequence of sequence of a certain type, is handled in the same way, where the definition of the sequences is included at the place of the struct.

> 成员的情况是某种类型的序列的序列，以相同的方式处理，其中序列的定义包含在结构的位置。

### Example of sequence of struct

Given the IDL struct definitions:

```C
struct coord_t{
    long x, y;
    unsigned long z;
};

struct M {
    sequence<coord_t> coords;
};
```

will need the following operation codes:

```C
DDS_OP_ADR | DDS_OP_TYPE_SEQ | DDS_OP_SUBTYPE_STU, offsetof (M, coords),
sizeof (coord_t), (11u << 16u) + 4u,
DDS_OP_ADR | DDS_OP_TYPE_4BY, offsetof (coord_t, x),
DDS_OP_ADR | DDS_OP_TYPE_4BY, offsetof (coord_t, y),
DDS_OP_ADR | DDS_OP_TYPE_4BY, offsetof (coord_t, z),
DDS_OP_RTS,
DDS_OP_RTS,
```

In expression [(11u << 16u) + 4u]{.title-ref} in the codes, the [11u]{.title-ref} represents the jmp address and the [4u]{.title-ref} the jsr address.

> 在代码中的表达式[(11u<<16u)+4u]{.title-ref}中，[11u]{.title-rev}表示 jmp 地址，[4u]{\title-ref}表示 jsr 地址。

Note that there are two [DDS_OP_RTS]{.title-ref}. The last one is to indicate the end of the IDL struct [M]{.title-ref}. The first indicates the end of the IDL stuct [coord_t]{.title-ref}, which is used in the sequence.

## Union

The operation code of a union is followed by a number specifying the number of cases. This is followed by a combination of jsr and jmp addresses. The jsr address specifies the start of the cases. A case consists of a JEQ operation with a type and an optional jump address. When a case exists of a structure, the jump address specifies the offset (from the start of the current case) of the struct definition (which is terminated with a return operation).

> 并集的操作代码后面跟着一个指定事例数的数字。接下来是 jsr 和 jmp 地址的组合。jsr 地址指定了案例的开始。一个案例由一个带有类型和可选跳转地址的 JEQ 操作组成。当结构存在事例时，跳转地址指定结构定义(以返回操作结束)的偏移量(从当前事例的开始)。

### Example of a union with a struct

Given the IDL definitions:

```C
struct coord_t{
    long x, y;
    unsigned long z;
};

union u switch (short) {
    case 0:
        char ch;
    case 1:
        coord_t coord;
};

struct s{
    u u_val;
};
```

will need the following operation codes:

> 将需要以下操作代码：

```C
DDS_OP_ADR | DDS_OP_TYPE_UNI | DDS_OP_SUBTYPE_2BY, offsetof (s, u_val._d), 2u, (17u << 16) + 4u,
DDS_OP_JEQ | DDS_OP_TYPE_1BY | 0, 0, offsetof (s, u_val._u.ch),
DDS_OP_JEQ | DDS_OP_TYPE_STU | 3, 1, offsetof (s, u_val._u.coord),
DDS_OP_ADR | DDS_OP_TYPE_4BY, offsetof (coord_t, x),
DDS_OP_ADR | DDS_OP_TYPE_4BY, offsetof (coord_t, y),
DDS_OP_ADR | DDS_OP_TYPE_4BY, offsetof (coord_t, z),
DDS_OP_RTS,
DDS_OP_RTS,
```

In thus [u_val]{.title-ref} stands for C-struct that is used for defining the IDL-union, where [u_val._d]{.title-ref} represents the switch parameter and the [u_val._u]{.title-ref} the union. In this [2u]{.title-ref} stands for the number of cases. For the union [3]{.title-ref} represents the jmp address to the operation code for the [coord_t]{.title-ref} struct.

> 因此，[u_val]｛.title-ref}代表用于定义 IDL 并集的 C 结构，其中[u_val-_d]｛.title-ref｝表示开关参数，[u_val-_u]｛\title-ref1｝表示并集。在这个[2u]{.title-ref}中，代表案例的数量。对于并集[3]｛.title-ref｝表示[cord_t]｛.title-ref}结构的操作代码的 jmp 地址。

## Recursive types

The current implementation does not support recursive types. With a recursive type it is not possible to follow the above procedure because it will lead to an infinite sequence of operation codes. The operation also contain a jump subroutine operation, called JSR, that has a 16 bit signed integer value as an offset to the location where the code starts. It is thus possible to execute operation codes that have been defined before. There are two methods for deciding when to use a jump subroutine operation:

> 当前实现不支持递归类型。对于递归类型，不可能遵循上述过程，因为这将导致操作代码的无限序列。该操作还包含一个称为 JSR 的跳转子例程操作，它有一个 16 位有符号整数值作为代码开始位置的偏移量。因此，可以执行之前已经定义的操作代码。有两种方法可以决定何时使用跳转子例程操作：

1.  Whenever a recursion is detected.
2.  Whenever a description of a struct already has been generated. The second method could lead to less operations, where the first method could lead to slightly efficient execution. In practice, this probably won't make much difference. The second method is slightly easier to implement: simple maintain a map of structures to offsets (of the start of a struct description from the start of the sequence).

> 1. 每当检测到递归时。
> 2. 只要已经生成了结构的描述。第二种方法可能导致更少的操作，而第一种方法可能会导致稍微高效的执行。在实践中，这可能不会有太大区别。第二种方法稍微容易实现：简单地维护结构到偏移量的映射(从序列开始的结构描述的开始)。

### Example

Give the IDL defintion:

> 给出 IDL 的定义：

```C
struct x {
    char ch;
    sequence<x> xs;
}
```

The following operation codes can be used:

> 可以使用以下操作代码：

```C
DDS_OP_ADR | DDS_OP_TYPE_1BY, offsetof (x, ch),
DDS_OP_ADR | DDS_OP_TYPE_SEQ | DDS_OP_SUBTYPE_STU, offsetof (x, xs),
sizeof (coord_t), (7u << 16u) + 4u,
DDS_OP_JSR, -6,
DDS_OP_RTS,
DDS_OP_RTS,
```

Here the [-6]{.title-ref} specifies that operation codes for the structure of the sequence, start 6 positions before the [DDS_OP_JSR]{.title-ref} operation. The first [DDS_OP_RTS]{.title-ref} indicates the end of the sequence type.

> 这里的[-6]｛.title-ref｝指定序列结构的操作代码，在[DDS_OP_JSR]｛.title-ref}操作之前的 6 个位置开始。第一个[DDS_OP_RTS]｛.title-ref｝表示序列类型的结束。

# Implementation

During the generation of operation codes, the tree needs to be traversed (at least) twice, because the values for the various jmp addresses need to be calculated.

> 在生成操作代码的过程中，树需要遍历(至少)两次，因为需要计算各种 jmp 地址的值。
